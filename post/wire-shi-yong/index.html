<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>wire 使用 | Gridea</title>
<link rel="shortcut icon" href="https://diuyon.github.io/favicon.ico?v=1641737589332">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://diuyon.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="wire 使用 | Gridea - Atom Feed" href="https://diuyon.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="wire 使用

参考：https://github.com/DuanJiaNing/thewaytowire/blob/main/wire_gen.go
https://www.cnblogs.com/binHome/p/14123295..." />
    <meta name="keywords" content="工具库,go" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://diuyon.github.io">
  <img class="avatar" src="https://diuyon.github.io/images/avatar.png?v=1641737589332" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              wire 使用
            </h2>
            <div class="post-info">
              <span>
                2022-01-09
              </span>
              <span>
                4 min read
              </span>
              
                <a href="https://diuyon.github.io/tag/_s-mPB61w/" class="post-tag">
                  # 工具库
                </a>
              
                <a href="https://diuyon.github.io/tag/Km4CC3KT1/" class="post-tag">
                  # go
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="wire-使用">wire 使用</h1>
<blockquote>
<p>参考：https://github.com/DuanJiaNing/thewaytowire/blob/main/wire_gen.go<br>
https://www.cnblogs.com/binHome/p/14123295.html，https://github.com/google/wire/blob/main/_tutorial/README.md</p>
</blockquote>
<p>[TOC]</p>
<h2 id="前提">前提</h2>
<p>在我们日常开发过程中，有些对象常常依赖另一些对象的方法或者属性，如果在需要使用时才去创建依赖的对象，久而久之依赖的对象替换起来就会变得特别麻烦。如果你在创建对象时就把需要依赖的对象传入进来，设置为属性，在需要使用时去引用这个属性的话，我们替换时只需要更换传入对象即可，这就叫做<strong>依赖注入（DI）</strong>。</p>
<p>**为什么使用这个工具？**当我们项目逐渐壮大时，会发现需要依赖注入的地方会特别特别多，手动维护效率很低。我们使用这个工具目的就是让它帮我生成那些依赖注入的代码，达到管理依赖注入的效果。</p>
<p><strong>你需要正确的使用这个工具</strong>：</p>
<ol>
<li>依赖之间传递必须为复杂对象，而非基础类型；</li>
<li>以管理依赖的目的去使用它；</li>
</ol>
<h2 id="使用">使用</h2>
<h3 id="安装">安装</h3>
<pre><code class="language-go">go get github.com/google/wire/cmd/wire
</code></pre>
<h3 id="编写需要-di-的代码">编写需要 DI 的代码</h3>
<p>例如下面的代码：</p>
<pre><code class="language-go">package internal

import &quot;fmt&quot;

type Message string

func NewMessage(m string) Message {
	return Message(m)
}

type Greeter struct {
	m    Message
	Name string
}

// Greeter 创建需要依赖 Message
func NewGreeter(m Message) *Greeter {
	return &amp;Greeter{m: m}
}

func (g Greeter) Say() {
	fmt.Println(string(g.m))
}
</code></pre>
<h3 id="编写管理-di-的代码">编写管理 DI 的代码</h3>
<pre><code class="language-go">//go:build wireinject
// +build wireinject

package main

import (
	&quot;wire-test/internal&quot;

	&quot;github.com/google/wire&quot;
)

func setup(m string) *internal.Greeter {
  panic(wire.Build(internal.NewGreeter, internal.NewMessage))
}

</code></pre>
<p>解释上面代码：</p>
<ol>
<li><code>// +build wireinject</code> 其中<code>+build xxx</code> 表示指定<code>go build</code> 在什么环境下才编译这个文件，一般加这个tag的话会配合<code>go build -t xxx</code> 来指定当前编译的环境，默认会读取当前执行环境<code>linux or darwin or windows</code>，这里必须指定是 <code>wireinject</code> 才会被工具识别的去生成代码。</li>
<li><code>//go:build</code> 这行代码是编译器自动给你加上的，不用管。</li>
<li><code>wire.Build</code> 中填入需要被生成管理的依赖对象，顺序随意。</li>
<li><code>panic</code>只是为了防止编译报错使得程序飞正常退出的手段。</li>
<li><code>// +build</code> 标识和 <code>setup</code> 返回需要在该页面代码完成最后加入和删除。</li>
</ol>
<h3 id="生成效果">生成效果</h3>
<pre><code class="language-go">// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	&quot;wire-test/internal&quot;
)

// Injectors from wire.go:

func setup(m string) *internal.Greeter {
	message := internal.NewMessage(m)
	greeter := internal.NewGreeter(message)
	return greeter
}

</code></pre>
<p>生成的文件名叫 <code>wire_gen.go</code>，生成好后，你就可以在 主函数中引用它了。</p>
<h2 id="高级使用">高级使用</h2>
<h3 id="创建模块集">创建模块集</h3>
<p>目的是为了细致到各目录管理依赖。</p>
<pre><code class="language-go">var androidProvider = wire.NewSet(initHuawei, initXiaomi)
wire.Build(androidProvider, initIos)
</code></pre>
<h3 id="为接口绑定指定类型">为接口绑定指定类型</h3>
<p>为了更方便识别入参 <code>interface</code> 实际为哪个 <code>struct</code></p>
<pre><code class="language-go">var set = wire.NewSet(
    fooClassProvider, 
    wire.Bind(new(FooInf), new(*FooClass) // bind class to interface， FooInf is interface，FooClass is struct，Bind 同样不讲顺序
)
</code></pre>
<h3 id="创建一个-struct-接收返回的依赖">创建一个 struct 接收返回的依赖</h3>
<pre><code class="language-go">var handlerSet = wire.NewSet(user.NewHandler, tests.NewHandler, wire.Struct(new(Handlers), &quot;*&quot;)) // 除了 * 还可指定 User 或者 Tests 或者两个都要

// 生成后
handler := user.NewHandler(service, imageService)
testsHandler := tests.NewHandler()
handlers := &amp;Handlers{
  User:  handler,
  Tests: testsHandler,
}
</code></pre>
<h3 id="创建一个变量">创建一个变量</h3>
<p>不常用</p>
<pre><code class="language-go">var configSet = wire.NewSet(wire.Value(conf.ConfigFilePath(&quot;config.yaml&quot;)), conf.Load)

// 生成后以及被使用
var (
	_wireConfigFilePathValue = conf.ConfigFilePath(&quot;config.yaml&quot;)
)
configFilePath := _wireConfigFilePathValue
config, err := conf.Load(configFilePath)
</code></pre>
<h3 id="指定生成的对象的属性去传递">指定生成的对象的属性去传递</h3>
<pre><code class="language-go">wire.Build(provideFoo, wire.FieldsOf(new(Foo), &quot;Bar&quot;))

// 生成后
func provideBar(foo Foo)*Bar{
    return foo.Bar
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#wire-%E4%BD%BF%E7%94%A8">wire 使用</a>
<ul>
<li><a href="#%E5%89%8D%E6%8F%90">前提</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85">安装</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E9%9C%80%E8%A6%81-di-%E7%9A%84%E4%BB%A3%E7%A0%81">编写需要 DI 的代码</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E7%AE%A1%E7%90%86-di-%E7%9A%84%E4%BB%A3%E7%A0%81">编写管理 DI 的代码</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E6%95%88%E6%9E%9C">生成效果</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8">高级使用</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E9%9B%86">创建模块集</a></li>
<li><a href="#%E4%B8%BA%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B">为接口绑定指定类型</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-struct-%E6%8E%A5%E6%94%B6%E8%BF%94%E5%9B%9E%E7%9A%84%E4%BE%9D%E8%B5%96">创建一个 struct 接收返回的依赖</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">创建一个变量</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E7%94%9F%E6%88%90%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8E%BB%E4%BC%A0%E9%80%92">指定生成的对象的属性去传递</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://diuyon.github.io/post/b-shu-he-bshu/">
              <h3 class="post-title">
                B树和B+树
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://diuyon.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
